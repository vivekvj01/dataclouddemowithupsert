"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterSecrets = exports.HIDDEN = void 0;
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const ts_types_1 = require("@salesforce/ts-types");
const sfdc_1 = require("../util/sfdc");
exports.HIDDEN = 'HIDDEN';
// Match all json attribute values case insensitive: ex. {" Access*^&(*()^* Token " : " 45143075913458901348905 \n\t" ...}
const buildTokens = (expElement) => new RegExp(`(['"][^'"]*${expElement}[^'"]*['"]\\s*:\\s*)['"][^'"]*['"]`, 'gi');
// Match all key value attribute case insensitive: ex. {" key\t"    : ' access_token  ' , " value " : "  dsafgasr431 " ....}
const buildKeyRegex = (expElement) => RegExp(`(['"]\\s*key\\s*['"]\\s*:)\\s*['"]\\s*${expElement}\\s*['"]\\s*.\\s*['"]\\s*value\\s*['"]\\s*:\\s*['"]\\s*[^'"]*['"]`, 'gi');
// This will redact values when the keys match certain patterns
const FILTERED_KEYS = [
    { name: 'sid' },
    { name: 'Authorization' },
    // Any json attribute that contains the words "refresh" and "token" will have the attribute/value hidden
    { name: 'refresh_token', regex: 'refresh[^\'"]*token' },
    { name: 'clientsecret' },
    { name: 'authcode' },
];
const FILTERED_KEYS_FOR_PROCESSING = FILTERED_KEYS.map((key) => ({
    ...key,
    regexTokens: buildTokens(key.regex ?? key.name),
    hiddenAttrMessage: `"<${key.name} - ${exports.HIDDEN}>"`,
    keyRegex: buildKeyRegex(key.regex ?? key.name),
}));
const compose = (...fns) => fns.reduce((prevFn, nextFn) => (value) => prevFn(nextFn(value)));
const replacementFunctions = FILTERED_KEYS_FOR_PROCESSING.flatMap((key) => [
    // two functions to run across each key
    (input) => input.replace(key.regexTokens, `$1${key.hiddenAttrMessage}`),
    (input) => input.replace(key.keyRegex, `$1${key.hiddenAttrMessage}`),
]).concat([
    // plus any "generalized" functions that are matching contents regardless of keys
    // use these for secrets with known patterns
    (input) => input
        .replace(new RegExp(sfdc_1.accessTokenRegex, 'g'), '<REDACTED ACCESS TOKEN>')
        .replace(new RegExp(sfdc_1.sfdxAuthUrlRegex, 'g'), '<REDACTED AUTH URL TOKEN>'),
    // conditional replacement for clientId: leave the value if it's the PlatformCLI, otherwise redact it
    (input) => input.replace(/(['"]client.*Id['"])\s*:\s*(['"][^'"]*['"])/gi, (all, key, value) => value.includes('PlatformCLI') ? `${key}:${value}` : `${key}:"<REDACTED CLIENT ID>"`),
]);
const fullReplacementChain = compose(...replacementFunctions);
/**
 *
 * @param args you *probably are passing this an object, but it can handle any type
 * @returns
 */
const filterSecrets = (...args) => args.map((arg) => {
    if (!arg) {
        return arg;
    }
    if ((0, ts_types_1.isArray)(arg)) {
        return (0, exports.filterSecrets)(...arg);
    }
    // Normalize all objects into a string. This includes errors.
    if (arg instanceof Buffer) {
        return '<Buffer>';
    }
    if ((0, ts_types_1.isObject)(arg)) {
        return JSON.parse(fullReplacementChain(JSON.stringify(arg)));
    }
    if ((0, ts_types_1.isString)(arg)) {
        return fullReplacementChain(arg);
    }
    return '';
});
exports.filterSecrets = filterSecrets;
//# sourceMappingURL=filters.js.map