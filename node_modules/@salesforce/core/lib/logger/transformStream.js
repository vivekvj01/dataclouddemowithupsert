"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = default_1;
/*
 * Copyright (c) 2023, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const node_stream_1 = require("node:stream");
const unwrapArray_1 = require("../util/unwrapArray");
const filters_1 = require("./filters");
// eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-unsafe-assignment
const build = require('pino-abstract-transport');
function default_1() {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call
    return build(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (source) => {
        const myTransportStream = new node_stream_1.Transform({
            objectMode: true,
            transform(chunk, enc, cb) {
                if (debugAllows(chunk)) {
                    // uses the original logger's filters.
                    const filteredChunk = (0, unwrapArray_1.unwrapArray)((0, filters_1.filterSecrets)([chunk]));
                    const stringified = JSON.stringify(filteredChunk);
                    this.push(stringified.concat('\n'));
                }
                cb();
            },
        });
        // Set up pipeline with proper error handling
        (0, node_stream_1.pipeline)(source, myTransportStream, () => { });
        return myTransportStream;
    }, {
        // This is needed to be able to pipeline transports.
        enablePipelining: true,
    });
}
// Cache for debug regex to avoid recreating it on every message
let cachedDebugRegex = null;
let lastDebugPattern = null;
const debugAllows = (chunk) => {
    if (!process.env.DEBUG || process.env.DEBUG === '*')
        return true;
    if (typeof chunk.name !== 'string')
        return true;
    // Only create a new regex if the DEBUG pattern has changed
    if (process.env.DEBUG !== lastDebugPattern) {
        lastDebugPattern = process.env.DEBUG;
        cachedDebugRegex = new RegExp(process.env.DEBUG.replace(/\*/g, '.*'));
    }
    // Use the cached regex for pattern matching
    return cachedDebugRegex.test(chunk.name);
};
//# sourceMappingURL=transformStream.js.map