import type * as nodeFs from 'node:fs';
import type { IFs as MemFs } from 'memfs';
type NodeFs = typeof nodeFs;
type CommonKeys<T, U> = keyof T & keyof U;
type IntersectionType<T, U> = {
    [K in CommonKeys<T, U>]: T[K] extends (...args: any[]) => any ? T[K] extends U[K] ? T[K] : U[K] extends T[K] ? U[K] : any : T[K] extends U[K] ? T[K] : U[K] extends T[K] ? U[K] : T[K];
};
type BaseVirtualFs = IntersectionType<NodeFs, MemFs>;
export type VirtualFs = Omit<BaseVirtualFs, 'writeFileSync' | 'readFileSync' | 'statSync' | 'promises' | 'mkdtempSync' | 'createWriteStream' | 'mkdirSync'> & {
    promises: Omit<BaseVirtualFs['promises'], 'writeFile' | 'readFile'> & {
        writeFile: (file: string, data: string | Buffer, options?: BufferEncoding | {
            encoding?: BufferEncoding;
            mode?: string | number;
        }) => Promise<void>;
        readFile: {
            (path: string): Promise<Buffer>;
            (path: string, encoding: BufferEncoding): Promise<string>;
        };
    };
    readFileSync: {
        (path: string): Buffer;
        (path: string, encoding: BufferEncoding): string;
    };
    writeFileSync: (file: string, data: string | Buffer, encoding?: BufferEncoding) => void;
    /** there are some differences between node:fs and memfs for statSync around bigint stats.  Be careful if using those */
    statSync: typeof nodeFs.statSync;
    mkdtempSync: typeof nodeFs.mkdtempSync;
    createWriteStream: typeof nodeFs.createWriteStream;
    mkdirSync: typeof nodeFs.mkdirSync;
};
export {};
