"use strict";
/*
 * Copyright (c) 2025, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mutex = void 0;
/**
 * A mutual exclusion (mutex) class that ensures only one asynchronous operation
 * can execute at a time, providing thread-safe execution of critical sections.
 *
 * @example
 * ```typescript
 * const mutex = new Mutex();
 *
 * // Only one of these will execute at a time
 * mutex.lock(async () => {
 *   // Critical section code here
 *   return someAsyncOperation();
 * });
 * ```
 */
class Mutex {
    /**
     * Internal promise chain that maintains the mutex state.
     * Each new lock acquisition is chained to this promise.
     *
     * @private
     */
    mutex = Promise.resolve();
    /**
     * Acquires the mutex lock and executes the provided function.
     * The function will not execute until all previously queued operations complete.
     *
     * @template T - The return type of the function
     * @param fn - The function to execute while holding the mutex lock. Can be synchronous or asynchronous.
     * @returns A promise that resolves with the result of the function execution
     *
     * @example
     * ```typescript
     * const result = await mutex.lock(async () => {
     *   // This code is guaranteed to run exclusively
     *   return await someAsyncOperation();
     * });
     * ```
     */
    async lock(fn) {
        const unlock = await this.acquire();
        try {
            return await fn();
        }
        finally {
            unlock();
        }
    }
    /**
     * Acquires the mutex by waiting for the current promise chain to resolve
     * and returns a release function to unlock the mutex.
     *
     * @private
     * @returns A promise that resolves to a function that releases the mutex lock
     */
    async acquire() {
        let release;
        const promise = new Promise((resolve) => {
            release = resolve;
        });
        const currentMutex = this.mutex;
        this.mutex = this.mutex.then(() => promise);
        await currentMutex;
        return release;
    }
}
exports.Mutex = Mutex;
//# sourceMappingURL=mutex.js.map