import { AsyncOptionalCreatable } from '@salesforce/kit';
import { AnyJson, Dictionary, JsonMap, Optional } from '@salesforce/ts-types';
import { Config, ConfigPropertyMeta } from './config';
/**
 * Information about a config property.
 */
export type ConfigInfo = {
    /**
     * key The config key.
     */
    key: string;
    /**
     * The location of the config property.
     */
    location?: ConfigAggregator.Location;
    /**
     * The config value.
     */
    value?: AnyJson;
    /**
     * The path of the config value.
     */
    path?: string;
    /**
     * `true` if the config property is in the local project.
     */
    isLocal: () => boolean;
    /**
     * `true` if the config property is in the global space.
     */
    isGlobal: () => boolean;
    /**
     * `true` if the config property is an environment variable.
     */
    isEnvVar: () => boolean;
    /**
     * True if the config property is deprecated.
     */
    deprecated?: boolean;
};
/**
 * Aggregate global and local project config files, as well as environment variables for
 * `config.json`. The resolution happens in the following bottom-up order:
 *
 * 1. Environment variables  (`SF_LOG_LEVEL`)
 * 1. Workspace settings  (`<workspace-root>/.sf/config.json`)
 * 1. Global settings  (`$HOME/.sf/config.json`)
 *
 * Use {@link ConfigAggregator.create} to instantiate the aggregator.
 *
 * ```
 * const aggregator = await ConfigAggregator.create();
 * console.log(aggregator.getPropertyValue('target-org'));
 * ```
 */
export declare class ConfigAggregator extends AsyncOptionalCreatable<ConfigAggregator.Options> {
    protected static encrypted: boolean;
    protected static instances: Map<string, ConfigAggregator>;
    private static readonly mutex;
    private allowedProperties;
    private readonly localConfig?;
    private readonly globalConfig;
    private envVars;
    /**
     * **Do not directly construct instances of this class -- use {@link ConfigAggregator.create} instead.**
     *
     * @ignore
     */
    constructor(options?: ConfigAggregator.Options);
    private get config();
    static create<T extends ConfigAggregator>(this: new (options?: ConfigAggregator.Options) => T, options?: ConfigAggregator.Options): Promise<T>;
    static create<P extends ConfigAggregator.Options, T extends AsyncOptionalCreatable<P>>(this: new (options?: P) => T, options?: P): Promise<T>;
    /**
     * Clear the cache to force reading from disk.
     * If no projectPath is provided, all instances will be cleared.
     *
     * *NOTE: Only call this method if you must and you know what you are doing.*
     */
    static clearInstance(projectPath?: string): Promise<void>;
    /**
     * Get the info for a given key. If the ConfigAggregator was not asynchronously created OR
     * the {@link ConfigAggregator.reload} was not called, the config value may be encrypted.
     *
     * @param key The config key.
     */
    static getValue(key: string, projectPath?: string): ConfigInfo;
    /**
     * Get the static ConfigAggregator instance. If one doesn't exist, one will be created with
     * the **encrypted** config values. Encrypted config values need to be resolved
     * asynchronously by calling {@link ConfigAggregator.reload}
     */
    private static getInstance;
    /**
     * Initialize this instances async dependencies.
     */
    init(): Promise<void>;
    /**
     * Get a resolved config property.
     * If you use a deprecated property, a warning will be emitted and it will attempt to resolve the new property's value
     *
     * **Throws** *{@link SfError}{ name: 'UnknownConfigKeyError' }* An attempt to get a property that's not supported.
     *
     * @param key The key of the property.
     */
    getPropertyValue<T extends AnyJson>(key: string): Optional<T>;
    /**
     * Get a resolved config property meta.
     * If the property is deprecated, it will return the new key's meta, if it exists, with a deprecation warning
     *
     * **Throws** *{@link SfError}{ name: 'UnknownConfigKeyError' }* An attempt to get a property that's not supported.
     *
     * @param key The key of the property.
     */
    getPropertyMeta(key: string): ConfigPropertyMeta;
    /**
     * Get a resolved config property.
     * If a property is deprecated, it will try to use the the new key, if there is a config there.
     *
     * @param key The key of the property.
     * @param throwOnDeprecation True, if you want an error throw when reading a deprecated config
     */
    getInfo(key: string, throwOnDeprecation?: boolean): ConfigInfo;
    /**
     * Gets a resolved config property location.
     *
     * For example, `getLocation('logLevel')` will return:
     * 1. `Location.GLOBAL` if resolved to an environment variable.
     * 1. `Location.LOCAL` if resolved to local project config.
     * 1. `Location.ENVIRONMENT` if resolved to the global config.
     *
     * @param key The key of the property.
     */
    getLocation(key: string): Optional<ConfigAggregator.Location>;
    /**
     * Get a resolved file path or environment variable name of the property.
     *
     * For example, `getPath('logLevel')` will return:
     * 1. `$SF_LOG_LEVEL` if resolved to an environment variable.
     * 1. `./.sf/config.json` if resolved to the local config.
     * 1. `~/.sf/config.json` if resolved to the global config.
     * 1. `undefined`, if not resolved.
     *
     * **Note:** that the path returned may be the absolute path instead of
     * relative paths such as `./` and `~/`.
     *
     * @param key The key of the property.
     */
    getPath(key: string): Optional<string>;
    /**
     * Get all resolved config property keys, values, locations, and paths.
     *
     * ```
     * > console.log(aggregator.getConfigInfo());
     * [
     *     { key: 'logLevel', val: 'INFO', location: 'Environment', path: '$SF_LOG_LEVEL'}
     *     { key: 'target-org', val: '<username>', location: 'Local', path: './.sf/config.json'}
     * ]
     * ```
     */
    getConfigInfo(): ConfigInfo[];
    /**
     * Get the local project config instance.
     */
    getLocalConfig(): Config | undefined;
    /**
     * Get the global config instance.
     */
    getGlobalConfig(): Config;
    /**
     * Get the resolved config object from the local, global and environment config instances.
     */
    getConfig(): JsonMap;
    unsetByValue(key: string): Promise<void>;
    /**
     * Get the config properties that are environment variables.
     */
    getEnvVars(): Dictionary<string>;
    /**
     * Re-read all property configurations from disk.
     */
    reload(): Promise<ConfigAggregator>;
    /**
     * Add an allowed config property.
     */
    addAllowedProperties(configMetas: ConfigPropertyMeta | ConfigPropertyMeta[]): void;
    /**
     * Set the allowed properties.
     *
     * @param properties The properties to set.
     */
    protected setAllowedProperties(properties: ConfigPropertyMeta[]): void;
    /**
     * Get the allowed properties.
     */
    protected getAllowedProperties(): ConfigPropertyMeta[];
    /**
     * Loads all the properties and aggregates them according to location.
     */
    protected loadProperties(): Promise<void>;
    /**
     * Loads all the properties and aggregates them according to location.
     */
    private loadPropertiesSync;
    private resolveProperties;
}
export declare namespace ConfigAggregator {
    /**
     * An enum of all possible locations for a config value.
     */
    const enum Location {
        /**
         * Represents the global config.
         */
        GLOBAL = "Global",
        /**
         * Represents the local project config.
         */
        LOCAL = "Local",
        /**
         * Represents environment variables.
         */
        ENVIRONMENT = "Environment"
    }
    type Options = {
        customConfigMeta?: ConfigPropertyMeta[];
        /** an absolute path to the project root */
        projectPath?: string;
    };
}
