import * as http from 'node:http';
import { AsyncCreatable } from '@salesforce/kit';
import { AuthInfo } from './org/authInfo';
import { JwtOAuth2Config } from './org/authInfo';
/**
 * Handles the creation of a web server for web based login flows.
 *
 * Usage:
 * ```
 * const oauthConfig = {
 *   loginUrl: this.flags.instanceurl,
 *   clientId: this.flags.clientid,
 * };
 *
 * const oauthServer = await WebOAuthServer.create({ oauthConfig });
 * await oauthServer.start();
 * await open(oauthServer.getAuthorizationUrl(), { wait: false });
 * const authInfo = await oauthServer.authorizeAndSave();
 * ```
 */
export declare class WebOAuthServer extends AsyncCreatable<WebOAuthServer.Options> {
    static DEFAULT_PORT: number;
    private authUrl;
    private logger;
    private webServer;
    private oauth2;
    private oauthConfig;
    private oauthError;
    private clientApp?;
    private username?;
    constructor(options: WebOAuthServer.Options);
    /**
     * Returns the configured oauthLocalPort or the WebOAuthServer.DEFAULT_PORT
     *
     * @returns {Promise<number>}
     */
    static determineOauthPort(): Promise<number>;
    /**
     * Returns the authorization url that's used for the login flow
     *
     * @returns {string}
     */
    getAuthorizationUrl(): string;
    /**
     * Executes the oauth request and creates a new AuthInfo when successful
     *
     * @returns {Promise<AuthInfo>}
     */
    authorizeAndSave(): Promise<AuthInfo>;
    /**
     * Starts the web server
     */
    start(): Promise<void>;
    protected init(): Promise<void>;
    /**
     * Executes the oauth request
     *
     * @returns {Promise<AuthInfo>}
     */
    private executeOauthRequest;
    /**
     * Parses the auth code from the request url
     *
     * @param response the http response
     * @param request the http request
     * @returns {Nullable<string>}
     */
    private parseAuthCodeFromRequest;
    /**
     * Closes the request
     *
     * @param request the http request
     */
    private closeRequest;
    /**
     * Validates that the state param in the auth url matches the state
     * param in the http request
     *
     * @param request the http request
     */
    private validateState;
}
export declare namespace WebOAuthServer {
    type Options = {
        oauthConfig: JwtOAuth2Config & {
            /**
             * OAuth scopes to be requested for the access token.
             *
             * This should be a string with each scope separated by spaces:
             * "refresh_token sfap_api chatbot_api web api"
             *
             * If not specified, all scopes assigned to the connected app are requested.
             */
            scope?: string;
        };
    } | {
        oauthConfig: JwtOAuth2Config & {
            /**
             * OAuth scopes to be requested for the access token.
             *
             * This should be a string with each scope separated by spaces:
             * "refresh_token sfap_api chatbot_api web api"
             *
             * If not specified, all scopes assigned to the connected app are requested.
             */
            scope?: string;
        };
        clientApp: string;
        username: string;
    };
    type Request = http.IncomingMessage & {
        query: {
            code: string;
            state: string;
            error?: string;
            error_description?: string;
        };
    };
}
/**
 * Handles the actions specific to the http server
 */
export declare class WebServer extends AsyncCreatable<WebServer.Options> {
    static DEFAULT_CLIENT_SOCKET_TIMEOUT: number;
    server: http.Server;
    port: number;
    host: string;
    private logger;
    private sockets;
    private redirectStatus;
    constructor(options: WebServer.Options);
    /**
     * Starts the http server after checking that the port is open
     */
    start(): Promise<void>;
    /**
     * Closes the http server and all open sockets
     */
    close(): void;
    /**
     * sends a response error.
     *
     * @param status the statusCode for the response.
     * @param message the message for the http body.
     * @param response the response to write the error to.
     */
    sendError(status: number, message: string, response: http.ServerResponse): void;
    /**
     * sends a response redirect.
     *
     * @param status the statusCode for the response.
     * @param url the url to redirect to.
     * @param response the response to write the redirect to.
     */
    doRedirect(status: number, url: string, response: http.ServerResponse): void;
    /**
     * sends a response to the browser reporting an error.
     *
     * @param error the oauth error
     * @param response the HTTP response.
     */
    reportError(error: Error, response: http.ServerResponse): void;
    /**
     * sends a response to the browser reporting the success.
     *
     * @param response the HTTP response.
     */
    reportSuccess(response: http.ServerResponse): void;
    /**
     * Preflight request:
     *
     * https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request
     * https://www.w3.org/TR/2020/SPSD-cors-20200602/#resource-preflight-requests
     */
    handlePreflightRequest(response: http.ServerResponse): void;
    handleSuccess(response: http.ServerResponse): Promise<void>;
    handleError(response: http.ServerResponse): Promise<void>;
    protected init(): Promise<void>;
    private handleRedirect;
    /**
     * Make sure we can't open a socket on the localhost/host port. It's important because we don't want to send
     * auth tokens to a random strange port listener. We want to make sure we can startup our server first.
     *
     * @private
     */
    private checkOsPort;
    /**
     * check and get the socket timeout form what was set in process.env.SFDX_HTTP_SOCKET_TIMEOUT
     *
     * @returns {number} - represents the socket timeout in ms
     * @private
     */
    private getSocketTimeout;
}
declare namespace WebServer {
    type Options = {
        port?: number;
        host?: string;
    };
}
export {};
