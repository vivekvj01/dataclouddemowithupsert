"use strict";
/*
 * Copyright (c) 2022, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateAggregator = void 0;
const kit_1 = require("@salesforce/kit");
const global_1 = require("../global");
const mutex_1 = require("../util/mutex");
const aliasAccessor_1 = require("./accessors/aliasAccessor");
const orgAccessor_1 = require("./accessors/orgAccessor");
const sandboxAccessor_1 = require("./accessors/sandboxAccessor");
class StateAggregator extends kit_1.AsyncOptionalCreatable {
    static instanceMap = new Map();
    static mutex = new mutex_1.Mutex();
    aliases;
    orgs;
    sandboxes;
    /**
     * Reuse a StateAggregator if one was already created for the current global state directory
     * Otherwise, create one and adds it to map for future reuse.
     * HomeDir might be stubbed in tests
     */
    static async getInstance() {
        return StateAggregator.mutex.lock(async () => {
            if (!StateAggregator.instanceMap.has(global_1.Global.DIR)) {
                StateAggregator.instanceMap.set(global_1.Global.DIR, await StateAggregator.create());
            }
            // TS assertion is valid because there either was one OR it was just now instantiated
            return StateAggregator.instanceMap.get(global_1.Global.DIR);
        });
    }
    /**
     * Clear the cache to force reading from disk.
     *
     * *NOTE: Only call this method if you must and you know what you are doing.*
     * *NOTE: This call is NOT thread-safe, so it should only be called when no other threads are using the StateAggregator.*
     */
    static clearInstance(path = global_1.Global.DIR) {
        StateAggregator.instanceMap.delete(path);
    }
    /**
     * Clear the cache to force reading from disk in a thread-safe manner.
     *
     * *NOTE: Only call this method if you must and you know what you are doing.*
     */
    static async clearInstanceAsync(path = global_1.Global.DIR) {
        return StateAggregator.mutex.lock(() => {
            StateAggregator.clearInstance(path);
        });
    }
    async init() {
        this.orgs = await orgAccessor_1.OrgAccessor.create();
        this.sandboxes = await sandboxAccessor_1.SandboxAccessor.create();
        this.aliases = await aliasAccessor_1.AliasAccessor.create();
    }
}
exports.StateAggregator = StateAggregator;
//# sourceMappingURL=stateAggregator.js.map