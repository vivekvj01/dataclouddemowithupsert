"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateRecordSubRequest = exports.UpdateRecordSubRequest = exports.DeleteRecordSubRequest = void 0;
class DeleteRecordSubRequest {
    constructor(type, id) {
        this.body = undefined;
        this.httpMethod = "DELETE";
        this.type = type;
        this.id = id;
    }
    buildUri(apiVersion) {
        return `/services/data/v${apiVersion}/sobjects/${this.type}/${this.id}`;
    }
    processResponse(statusCode, headers, body) {
        if (statusCode === 204) {
            return Promise.resolve({ id: this.id });
        }
        return Promise.reject(parseErrorResponse(body));
    }
}
exports.DeleteRecordSubRequest = DeleteRecordSubRequest;
class UpdateRecordSubRequest {
    constructor(record) {
        this.httpMethod = "PATCH";
        this.record = record;
        this.body = expandReferenceIds(record.fields);
        delete this.body.type;
        delete this.body.id;
    }
    buildUri(apiVersion) {
        return `/services/data/v${apiVersion}/sobjects/${this.record.type}/${this.record.fields.id}`;
    }
    processResponse(statusCode, headers, body) {
        if (statusCode === 204) {
            return Promise.resolve({ id: this.record.fields.id });
        }
        return Promise.reject(parseErrorResponse(body));
    }
}
exports.UpdateRecordSubRequest = UpdateRecordSubRequest;
class CreateRecordSubRequest {
    constructor(record) {
        this.httpMethod = "POST";
        this.record = record;
        this.body = expandReferenceIds(record.fields);
        delete this.body.type;
    }
    buildUri(apiVersion) {
        return `/services/data/v${apiVersion}/sobjects/${this.record.type}`;
    }
    processResponse(statusCode, headers, body) {
        if (statusCode === 201) {
            return Promise.resolve({ id: body.id });
        }
        return Promise.reject(parseErrorResponse(body));
    }
}
exports.CreateRecordSubRequest = CreateRecordSubRequest;
function parseErrorResponse(errorResponse) {
    return new Error(errorResponse
        .map((error) => {
        return error.errorCode + ": " + error.message;
    })
        .join("\n"));
}
function expandReferenceIds(fields) {
    const newFields = { ...fields };
    for (const [k, v] of Object.entries(newFields)) {
        if (isReferenceId(v)) {
            newFields[k] = v.toApiString();
        }
    }
    return newFields;
}
function isReferenceId(val) {
    return (val && typeof val === "object" && "toApiString" in val && "toString" in val);
}
